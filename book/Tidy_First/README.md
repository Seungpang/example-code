### 보호 구문
```java
if (조건)
    if (다른 조건 부정)
        ... 코드 ...
```
아래와 같이 변경 할 수 있음
```java
if (조건 부정) return
if (다른 조건) return
... 코드 ...
```

다만, 보호 구문을 남용하지는 말자
조건에 딱 부합하는 경우
```java
if (조건)
        ...루틴의 나머지 모든 코드..
```

정리하고 싶은데 정리할 수 없는 코드
```java
if (조건)
    ...코드...
... 다른 코드...
```

### 안 쓰는 코드
지워 버리자! 끝

### 대칭으로 맞추기
코드를 읽을 때 기존과 다르다면 `다른 동작의 코드겠지`라고 예단한다. 여기서 차이가 있다 보니,
같은 일임에도 다른 일인 것처럼 뜻이 흐려진다.

한 가지 방식을 선택해서 정하자. 다른 방식으로 작성한 코드를 선택한 방식으로 고치자


### 새로운 인터페이스로 기존 루틴 부르기
호출하고 싶은 인터페이스를 새롭게 구현해서 호출하자. 

새로 만든 인터페이스는 그저 기존 인터페이스를 호출하는 것으로 구현할 수 있다.  
(기존 인터페이스를 호출하는 코드를 새 인터페이스를 호출하도록 모두 이전한 후에는 이전 인터페이스를 제거하고 
새 인터페이스가 직접 루틴을 구현하도록 변경할 수 있다.)

아래의 경우 톨로 인터페이스 적용때와 비슷한 느낌을 받음
+ 거꾸로 코딩하기: 루틴의 마지막 줄부터 시작
+ 테스트 우선 코딩: 테스트부터 작성하여 통과 요건을 정함
+ 도우미 설계: 특정 업무를 해 주는 루틴, 객체, 서비스가 있다면 나머지 작업은 쉬움

### 읽는 순서
완벽한 순서는 없다. 때로는 기본 요소를 먼저 이해한 다음 구성 방법을 이해하고 싶을 때가 있고, API를 먼저 이해한 다음 세부 구현을 이해하고 싶을 때도 있다.

스스로가 코드를 읽어 왔을 테니 최근 경험을 살려 판단해라

### 응집도를 높이는 배치
가장 좋은 코드 정리법
```
결합도 제거 비용 + 변경 비용 < 결합도에 따른 비용 + 변경비용
```
아래와 같은 이유로 결합도 제거가 어려울 수 있음

+ 당장 어떻게 해야 할지 모른다면 결합도 제거가 곤란할 수 있다.
+ 할 수 있더라도 지금 당장은 시간적 여유가 없다면 결합도 제거는 부담스러운 시간 투자가 된다.
+ 팀이 이미 충분한 변경을 수행하고 있다면 결합도를 제거하는 일이 팀원 간의 잠재적 갈등으로 번질 수 있다.

응집도가 좋아지면 결합도 역시 덩달아 좋아진다.


### 선언과 초기화를 함께 옮기기
변수 선언과 초기화 위치는 종종 서로 떨어져 있기도 한다. 변수 이름에서 힌트를 얻어 프로그램에서 역할을 알게 되지만, 변수 초기화는 이름이 주는 의미를 더 강화한다.
타입이 포함된 선언과 초기화 코드가 떨어져 있기라도 하면 읽어 내기는 더 어려워 진다.


### 설명하는 변수
어렵고 크고 복잡한 코드의 표현식을 이해했다면 전체에서 일부 표현식을 추출한 후, 표현식의 의도가 드로나도록 변수 이름을 만들어 할당하자

```java
    public static void main(String[] args) {
        String name = "Kim Seungrae";
        System.out.println("Kim Seungrae".split(" ")[1].toUppercase());
    }
```

```java
    public static void main(String[] args) {
        String[] name = "Kim Seungrae".split(" ");
        String lastName = name[1];
        String uppercaseLastName = lastName.toUpperCase();
        System.out.println(uppercaseLastName);
    }
```

### 설명하는 상수
`상징적인 상수를 만드세요. 리터럴 상수로 사용된 곳은 상징적인 상수로 바꿉니다.`


### 명시적인 매개변수
코드를 읽는 중에 루틴에서 다루고 있는 일부 데이터가 명시적으로 전달되지 않는 것을 발견했다.

루틴을 나누자. 앞부분에서 매개변수 값을 채운 후, 뒷부분에서 명시적으로 전달한다.

```
params = {a : 1, b : 2}
foo(params)

function foo(params)
    ...params.a... ...params.b...
```

```
function foo(params)
    foo_body(params.a, params.b)
    
fuction foo_body(a, b)
    ...a... ...b..
```

매개변수를 명시적으로 드러나게 만든 다음, 함수를 연쇄적으로 호출할 수 있게 하자. 이렇게 만들면 코드는 읽기와 테스트, 분석이 쉬워진다.


### 비슷한 코드끼리
긴 코드 덩어리를 읽다가 `아, 이 부분은 이렇게 하고, 저 부분은 저렇게 하는구나`라고 구분이 될 때는 두 부분 사이에 빈 줄을 넣어 분리하자

제대로 된 소프트웨어 설계는 유연성을 확보하지만, 그렇지 못한 경우는 자칫 변화 자체를 망각하고 소프트웨어 설계의 소용돌이에 빠질 수 있다.

관련 있는 코드를 뭉쳐두면 다양한 길로 나아갈 수 있다. 


### 도우미 추출
목적이 분명하고 나머지 코드와는 상호작용이 적은 코드 블록을 만날 때가 있다. 그 코드 블록을 추려내고, 도우미로 추출한 후에 이름을 붙인다.

도우미를 만들다 보면, 몇 시간 혹은 몇 분만에 다시 사용하고 싶어 하는 자신의 욕구를 발견 할 겁니다.
이 과정에서 인터페이스는 문제를 생각하도록 이끄는 도구가 된다.

우리가 만든 설계 요소에 새로운 이름을 붙일 수 있을 때, 새로운 인터페이스가 떠오른다.

### 하나의 더미
코드를 만드는 데, 가장 큰 비용이 들어가는 일은 코드 작성이 아니라 읽고 이해하는 데 드는 비용이다. 코드 정리를 선행하면 더 작은 조각 단위로 결합을 제거하는 길을 제시하여 응집도를 높일 수 있다. 이론적으로는 그렇고, 실무적으로 말하면 한 번에 머릿속에 기억하고 있어야 할 코드의 상세 내용을 줄여준다.

작은 코드 조각을 지향하는 목적은 코드를 한 번에 조금씩 이해할 수 있도록 하는 것이다. 때때로 이 과정이 잘못될 수 있다. 작은 코드 조각들이 서로 교류하는 방식은 코드를 더 알기 어렵게 한다.

다음 증상들을 찾아보기
+ 길고 반복되는 인자 목록
+ 반복되는 코드, 그 중에서도 반복되는 조건문
+ 도우미에 대한 부적절한 이름
+ 공유되어 변경에 노출된 데이터 구조

더 작은 조각을 지향한다고 말하면서, 동시에 하나의 더미로 만드는 일은 앞뒤가 맞지 않은 느낌이 들기도 한다. 하지만 신기하게도 직접 해 보면 분명 만족을 느끼게 될 것이다.


### 설명하는 주석
코드를 읽다가 `아, 이건 이렇게 돌아가는 거구나!` 라는 생각이 드는 순간 기록해라

```
파일 앞에 주석이 없는 경우, 설명을 추가하여 파일을 읽을 사람이 얻게 될 유용함을 미리 알려줍니다. (알란 메르트너)
```

### 불필요한 주석 지우기
코드만으로 내용을 모두 이해할 수 있다면 주석은 삭제해라.
